import io.customer.shared.tracking.api.model.TrackingErrorReason;
import io.customer.shared.tracking.constant.QueueTaskStatus;
import kotlinx.datetime.Instant;

CREATE TABLE trackingTask (
  identifier TEXT NOT NULL,
  siteId TEXT NOT NULL,
  type TEXT NOT NULL,
  createdAt INTEGER AS Instant NOT NULL,
  expiresAt INTEGER AS Instant DEFAULT NULL,
  stalesAt INTEGER AS Instant DEFAULT NULL,
  identity TEXT,
  activityJson TEXT NOT NULL,
  activityModelVersion INTEGER,
  queueTaskStatus TEXT AS QueueTaskStatus NOT NULL,
  priority INTEGER NOT NULL DEFAULT 0,
  retryCount INTEGER NOT NULL DEFAULT 0,
  statusCode INTEGER DEFAULT NULL,
  errorReason TEXT AS TrackingErrorReason DEFAULT NULL,
  PRIMARY KEY (identifier, siteId)
);

-- INSERTIONS AND UPDATIONS

insert:
INSERT INTO trackingTask (identifier, siteId, type, createdAt, expiresAt, stalesAt, identity, activityJson, activityModelVersion, queueTaskStatus, priority)
VALUES (?, ?, ?,?, ?,?, ?, ?,?, ?, ?);

updateAllAnonymous:
UPDATE trackingTask SET identity = :identifier
WHERE identity IS NULL OR identity == '';

updateStatus:
UPDATE trackingTask SET queueTaskStatus = :status
WHERE identifier IN :ids;

updateWithFailure:
UPDATE trackingTask SET queueTaskStatus = :status, retryCount = retryCount + 1, statusCode = :statusCode, errorReason = :errorReason
WHERE identifier IN :ids;

-- DELETIONS

clearAll:
DELETE FROM trackingTask;

clearAllStale:
DELETE FROM trackingTask
WHERE stalesAt <= :timestamp;

clearAllWithStatus:
DELETE FROM trackingTask
WHERE queueTaskStatus == :status;

clearAllStaleOrSent:
DELETE FROM trackingTask
WHERE stalesAt <= :timestamp OR queueTaskStatus IN :status;

-- SELECTIONS

selectAll:
SELECT *
FROM trackingTask;

selectAllAnonymous:
SELECT * FROM trackingTask
WHERE identity IS NULL OR identity == '';

selectAllPending:
SELECT * FROM trackingTask
WHERE queueTaskStatus IN :status AND (identity IS NOT NULL OR identity == '')
ORDER BY priority, createdAt
LIMIT :limit;
